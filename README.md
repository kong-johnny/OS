# OS
消息队列实验
实验目的：
了解和熟悉linux支持的消息通信机制。
实验任务：
使用linux系统提供的系统调用msgget(),msgrev(),msgctl()编制一个长度为1K的消息发送和接受的程序。
实验要求：
1.	用一个程序作为“引子”，先后fork()两个子进程，SERVER和CLIENT，进行通信。
2.	由SERVER端创建一个Key为75的消息队列，等待CLIENT端进程发来的消息。当遇到类型为1的消息，则作为结束信号，删除该队列，并退出SERVER。SERVER每接受到一个消息后显示一句“(Server)received from + CLIENT端pid+接受消息的类型”,然后发送一个返回消息给CLIENT端，显示一句“(Server)sent”。
3.	CLIENT端使用key为75的消息队列，先后发送类型从10到1的消息，然后退出。发出的最后一个消息是SERVER端需要的结束信号。CLIENT每发送一条消息后显示一句“(Client)sent+发送消息的类型”,然后等待接受SERVER端的返回消息后，显示一句“(Client) received from + SERVER端pid+接受消息的类型”，再在发送下一条消息。
4.	父进程在SERVER和CLIENT都退出后结束。
注意：请考虑如何保证先由SERVER端创建一个Key为75的消息队列后，CLIENT端才能使用该消息队列。
参考程序：
1.	消息队列通信（客户端程序，服务端程序）；
2.	管道通信；
3.	共享内存通信。
提示：
在linux中，打开gedit编辑器（在命令方式直接敲入gedit即可；将写好的程序输入并保存（假设保存为a.c）。然后在命令状态下敲入命令“gcc a.c –o a.exe”即生成一执行文件；你敲入“./a.exe”即可运行该执行文件了。
提供的相关资料：
消息队列的相关函数；管道通信的相关函数；共享内存的相关函数；其他常用的一些函数。

消息队列相关命令：
Ipcs ：显示所有的消息队列；
ipcrm：删除一个或更多的消息队列、信号量集或者共享内存标识。

上交要求：
	上交一份实验报告和源程序，实验报告包括：程序代码、运行结果、实验总结。
	实验报告命名为：学号_姓名_msg.docx，源程序命名为：学号_姓名_msg.c或.cpp，将源程序和实验报告打包为：学号_姓名_msg.rar，然后将打包文件发送到邮箱：os_experiment@126.com
	上交截止时间：10月7日24：00

